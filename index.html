<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Dru - Data Reconstruction Utility</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="css/dru.css?v=0.7.0" />
<style>
.hidden {
    display: none;
}

.switch {
    border-width: 1px 1px 0 1px;
    border-style: solid;
    border-color: #7a2518;
    display: inline-block;
}

.switch--item {
    padding: 10px;
    background-color: #ffffff;
    color: #7a2518;
    display: inline-block;
    cursor: pointer;
}

.switch--item.selected {
    background-color: #7a2519;
    color: #ffffff;
}

</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
    $('.primary').each(function() {
        primary = $(this);
        createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
        primary.children('.title').remove();
    });
    $('.secondary').each(function(idx, node) {
        secondary = $(node);
        primary = findPrimary(secondary);
        switchItem = createSwitchItem(secondary, primary.children('.switch'));
        switchItem.content.addClass('hidden');
        findPrimary(secondary).append(switchItem.content);
        secondary.remove();
    });
}

function createBlockSwitch(primary) {
    blockSwitch = $('<div class="switch"></div>');
    primary.prepend(blockSwitch);
    return blockSwitch;
}

function findPrimary(secondary) {
    candidate = secondary.prev();
    while (!candidate.is('.primary')) {
        candidate = candidate.prev();
    }
    return candidate;
}

function createSwitchItem(block, blockSwitch) {
    blockName = block.children('.title').text();
    content = block.children('.content').first().append(block.next('.colist'));
    item = $('<div class="switch--item">' + blockName + '</div>');
    item.on('click', '', content, function(e) {
        $(this).addClass('selected');
        $(this).siblings().removeClass('selected');
        e.data.siblings('.content').addClass('hidden');
        e.data.removeClass('hidden');
    });
    blockSwitch.append(item);
    return {'item': item, 'content': content};
}

$(addBlockSwitches);

</script>

</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Dru - Data Reconstruction Utility</h1>
<div class="details">
<span id="revnumber">version 0.7.0</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_installation">1. Installation</a></li>
<li><a href="#_setup">2. Setup</a></li>
<li><a href="#_source_mapping">3. Source Mapping</a></li>
<li><a href="#_property_and_type_mapping">4. Property and Type Mapping</a>
<ul class="sectlevel2">
<li><a href="#_default_values">4.1. Default Values</a></li>
<li><a href="#_overriding_properties">4.2. Overriding Properties</a></li>
<li><a href="#_aliasing_properties">4.3. Aliasing Properties</a></li>
<li><a href="#_ignoring_properties">4.4. Ignoring Properties</a></li>
<li><a href="#_conditional_type_mapping">4.5. Conditional Type Mapping</a></li>
<li><a href="#_nested_type_mapping">4.6. Nested Type Mapping</a></li>
<li><a href="#_partial_retrieval">4.7. Partial Retrieval</a></li>
</ul>
</li>
<li><a href="#_data_sets">5. Data Sets</a></li>
<li><a href="#_parsers">6. Parsers</a>
<ul class="sectlevel2">
<li><a href="#_reflection">6.1. Reflection</a></li>
<li><a href="#_json">6.2. JSON</a></li>
<li><a href="#_yaml">6.3. YAML</a></li>
</ul>
</li>
<li><a href="#_clients">7. Clients</a>
<ul class="sectlevel2">
<li><a href="#_pojo">7.1. POJO</a></li>
<li><a href="#_dynamodb">7.2. DynamoDB</a></li>
<li><a href="#_gorm">7.3. GORM</a></li>
<li><a href="#_micronaut_data">7.4. Micronaut Data</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="imageblock ribbon">
<div class="content">
<a class="image" href="https://github.com/agorapulse/dru"><img src="images/ribbon.png" alt="ribbon"></a>
</div>
</div>
<div class="paragraph">
<p>Dru is Data Reconstruction Utility which helps to create and maintain test data based on real-life production data as
it is for example often easier to grab production data of web application as JSON than trying to create selective
export from one or more data stores.</p>
</div>
<div class="paragraph">
<p>The quality of tests depends on the quality of the test data being used. It is important to keep the test data aligned
with the production data as much as it is possible. This was relatively easy in the time of relational databases'
dominance as test data can be set up with database dump but now, when the data required for the test can be stored in multiple
data the safest way to load test data is to use your own data persistence layer or underlying framework. Dru comes with
out of box support for Plain Old Java Objects (POJOs),
<a href="http://gorm.grails.org/">GORM</a> and <a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.html">AWS DynamoDB</a>.
It can consume JSON or YAML files as data sources.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Dru is designed to load complex data models. References by ids are translated into associations even the identity in
newly created data store is not the same as original one. For example if you have entity <code>Item</code> with <code>id</code> <code>5</code> and
entity <code>ItemComment</code> with property <code>itemId</code> with value <code>5</code> then the loaded <code>ItemComment</code> entity will have <code>itemId</code> property
set to the actual <code>id</code> of the loaded <code>Item</code> e.g. <code>1</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_installation"><a class="anchor" href="#_installation"></a>1. Installation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dru is available in JCenter. At the moment, you can use any of POJO, GORM or DynamoDB modules your project.</p>
</div>
<div class="listingblock">
<div class="title">Gradle Installation</div>
<div class="content">
<pre class="prettyprint highlight"><code>repositories {
    jcenter()
}

dependencies {
    // load just simple implementation with POJO client and reflection based parser
    testCompile "com.agorapulse:dru:0.7.0"

    // and pick any client
    testCompile "com.agorapulse:dru-client-dynamodb:0.7.0"
    testCompile "com.agorapulse:dru-client-gorm:0.7.0"
    testCompile "com.agorapulse:dru-client-micronaut-data:0.7.0"

    // and pick any parser
    testCompile "com.agorapulse:dru-parser-json:0.7.0"
    testCompile "com.agorapulse:dru-parser-yaml:0.7.0"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_setup"><a class="anchor" href="#_setup"></a>2. Setup</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>Dru</code> provides <code>Closable</code> interface. Calling <code>close</code> at the end of the test will guarantee that fresh data are loaded
for the next test. If you are using Spock then you can use <code>@AutoCleaenup</code> annotation on the field to call the <code>close</code>
method automatically.</p>
</div>
<div class="listingblock">
<div class="title">Simple Specification</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>package avl

import com.agorapulse.dru.Dru
import spock.lang.AutoCleanup
import spock.lang.Specification

/**
 * Test loading item.
 */
class ItemSpec extends Specification {


    @AutoCleanup Dru dru = Dru.create {                                                 <i class="conum" data-value="1"></i><b>(1)</b>
        from ('item.json') {                                                            <i class="conum" data-value="2"></i><b>(2)</b>
            map { to Item }                                                             <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }

    void 'entities can be access from the data set'() {
        expect:
            dru.findAllByType(Item).size() == 1                                         <i class="conum" data-value="4"></i><b>(4)</b>
        when:
            Item item = dru.findByTypeAndOriginalId(Item, ID)                           <i class="conum" data-value="5"></i><b>(5)</b>
        then:
            item
            item.name == 'PX-41'                                                        <i class="conum" data-value="6"></i><b>(6)</b>
            item.description == "The PX-41 is a very dangerous mutator engineered in the top secret PX-Labs, located in the Arctic Circle. It is capable of turning any living things in the world into a purple, furry, indestructible, mindless, killing machine that is so dangerous that it can destroy anything in its path."
            item.tags.contains('superpowers')
    }

    void 'all data are used'() {
        expect:
            dru.report.empty                                                            <i class="conum" data-value="7"></i><b>(7)</b>
    }

    private static final String ID = '050e4fcf-158d-4f44-9b8b-a6ba6809982e:PX-41'
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Prepare the data loading plan</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Load the content of <code>items.json</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Map the root element to <code>Item</code> entity</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Loaded entity is available by its type</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Entity can be loaded by its original id</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Properties are loaded as expected</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Check whether all properties from the source has been used</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can take a look at the <code>item.json</code> file containing the test data:</p>
</div>
<div class="listingblock">
<div class="title">item.json</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="json">{
  "id": "050e4fcf-158d-4f44-9b8b-a6ba6809982e",
  "name": "PX-41",
  "description": "The PX-41 is a very dangerous mutator engineered in the top secret PX-Labs, located in the Arctic Circle. It is capable of turning any living things in the world into a purple, furry, indestructible, mindless, killing machine that is so dangerous that it can destroy anything in its path.",
  "tags": [
    "mutator",
    "monsters",
    "superpowers"
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The file must be located inside a folder of same name as the class where the source was defined
i.g <code>avl/ItemSpec/item.json</code>, resp. <code>src/test/resources/avl/ItemSpec/item.json</code> for Gradle project.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_source_mapping"><a class="anchor" href="#_source_mapping"></a>3. Source Mapping</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can map directly to the root object or array or to any path inside the source you need:</p>
</div>
<div class="listingblock">
<div class="title">Complex Path</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('items.json') {
        map ('mission.items') {
            to Item
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">items.json</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="json">{
  "mission": {
    "items": [
      {
        "id": "050e4fcf-158d-4f44-9b8b-a6ba6809982e",
        "name": "PX-41",
        "description": "The PX-41 is a very dangerous mutator engineered in the top secret PX-Labs, located in the Arctic Circle. It is capable of turning any living things in the world into a purple, furry, indestructible, mindless, killing machine that is so dangerous that it can destroy anything in its path.",
        "tags": [
          "mutator",
          "monsters",
          "superpowers"
        ]
      }
    ]
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_property_and_type_mapping"><a class="anchor" href="#_property_and_type_mapping"></a>4. Property and Type Mapping</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For basic use cases when the source exactly fits the entity properties there is no need for additional mappings.</p>
</div>
<div class="sect2">
<h3 id="_default_values"><a class="anchor" href="#_default_values"></a>4.1. Default Values</h3>
<div class="paragraph">
<p>You can set a default value for a property. The object passed as argument to the closure
is the map obtained from the source.</p>
</div>
<div class="listingblock">
<div class="title">Default Value</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('item.json') {
        map {
            to (Item) {
                defaults {
                    description = "Description for $it.name"
                }
            }
        }
    }
}

void 'entities can be access from the data set'() {
    when:
        Item item = dru.findByTypeAndOriginalId(Item, ID)
    then:
        item
        item.name == 'PX-41'
        item.description == 'Description for PX-41'
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">item.json</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="json">{
  "id": "050e4fcf-158d-4f44-9b8b-a6ba6809982e",
  "name": "PX-41",
  "tags": [
    "mutator",
    "monsters",
    "superpowers"
  ]
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_overriding_properties"><a class="anchor" href="#_overriding_properties"></a>4.2. Overriding Properties</h3>
<div class="paragraph">
<p>You can override any value coming from the source. The object passed as argument to the closure is the map obtained from the source.
Contrary to defaults, the value is set to overridden value even it is present in the source.</p>
</div>
<div class="listingblock">
<div class="title">Overriding Properties</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('item.json') {
        map {
            to (Item) {
                overrides {
                    description = "Description for $it.name"
                }
            }
        }
    }
}

void 'entities can be access from the data set'() {
    when:
        Item item = dru.findByTypeAndOriginalId(Item, ID)
    then:
        item
        item.name == 'PX-41'
        item.description == 'Description for PX-41'
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">item.json</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="json">{
  "id": "050e4fcf-158d-4f44-9b8b-a6ba6809982e",
  "name": "PX-41",
  "description": "The PX-41 is a very dangerous mutator engineered in the top secret PX-Labs, located in the Arctic Circle. It is capable of turning any living things in the world into a purple, furry, indestructible, mindless, killing machine that is so dangerous that it can destroy anything in its path.",
  "tags": [
    "mutator",
    "monsters",
    "superpowers"
  ]
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_aliasing_properties"><a class="anchor" href="#_aliasing_properties"></a>4.3. Aliasing Properties</h3>
<div class="paragraph">
<p>You can alias properties with different names in the source and in the entity.</p>
</div>
<div class="listingblock">
<div class="title">Aliasing Properties</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('item.json') {
        map {
            to (Item) {
                map('desc') {
                    to (description: String)
                }
            }
        }
    }
}

void 'entities can be access from the data set'() {
    when:
        Item item = dru.findByTypeAndOriginalId(Item, ID)
    then:
        item
        item.name == 'PX-41'
        item.description == "The PX-41 is a very dangerous mutator engineered in the top secret PX-Labs, located in the Arctic Circle. It is capable of turning any living things in the world into a purple, furry, indestructible, mindless, killing machine that is so dangerous that it can destroy anything in its path."
        item.tags.contains('superpowers')
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">item.json</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="json">{
  "id": "050e4fcf-158d-4f44-9b8b-a6ba6809982e",
  "name": "PX-41",
  "desc": "The PX-41 is a very dangerous mutator engineered in the top secret PX-Labs, located in the Arctic Circle. It is capable of turning any living things in the world into a purple, furry, indestructible, mindless, killing machine that is so dangerous that it can destroy anything in its path.",
  "tags": [
    "mutator",
    "monsters",
    "superpowers"
  ]
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ignoring_properties"><a class="anchor" href="#_ignoring_properties"></a>4.4. Ignoring Properties</h3>
<div class="paragraph">
<p>If you want to be sure that every information from the source is persisted you can access
<code>MissingPropertiesReport</code> object from <code>Dru</code> instance. The report contains list of properties which
hasn&#8217;t been matched. If you explicitly ignore a property for example because it is derived it will not appear in the report.</p>
</div>
<div class="listingblock">
<div class="title">Ignoring Properties</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('item.json') {
        map {
            to (Item) {
                ignore 'owner'
            }
        }
    }
}

void 'owner does is not present in the report'() {
    when:
        dru.load()
    then:
        dru.report.empty
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">item.json</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="json">{
  "id": "050e4fcf-158d-4f44-9b8b-a6ba6809982e",
  "name": "PX-41",
  "description": "The PX-41 is a very dangerous mutator engineered in the top secret PX-Labs, located in the Arctic Circle. It is capable of turning any living things in the world into a purple, furry, indestructible, mindless, killing machine that is so dangerous that it can destroy anything in its path.",
  "owner": "Unknown",
  "tags": [
    "mutator",
    "monsters",
    "superpowers"
  ]
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conditional_type_mapping"><a class="anchor" href="#_conditional_type_mapping"></a>4.5. Conditional Type Mapping</h3>
<div class="paragraph">
<p>You can add condition to type mappings to map to different entities based on source properties.</p>
</div>
<div class="listingblock">
<div class="title">Conditional Mapping</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('persons.json') {
        map {
            to (Agent) {
                when { it.type == 'agent' }
                defaults { securityLevel = 1 }
            }
            to (Villain) {
                when { it.type == 'villain' }
            }
        }
    }
}

void 'entities are mapped to proper types'() {
    expect:
        dru.findAllByType(Agent).size() == 1
        dru.findAllByType(Villain).size() == 1
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">persons.json</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="json">[
  {
    "id": 12345,
    "name": "Felonius Gru",
    "bio": "Born from the family with long line of villainy and formerly the world's greatest villain.",
    "type": "agent"
  },
  {
    "id": 247,
    "name": "El Macho",
    "bio": "A former renowned, nearly superhuman-level strong bank robber who now wants to dominate the world",
    "type": "villain"
  }
]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_nested_type_mapping"><a class="anchor" href="#_nested_type_mapping"></a>4.6. Nested Type Mapping</h3>
<div class="paragraph">
<p>You can nest type mapping to maps complex hierarchical structures.</p>
</div>
<div class="listingblock">
<div class="title">Nested Mapping</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('agents.json') {
        map {
            to (Agent) {
                map ('manager') {
                    to (Agent) {
                        defaults { securityLevel = 1 }
                    }
                }
            }
        }
    }
}

void 'nested properties are mapped'() {
    expect:
        dru.findAllByType(Agent).size() == 2
        dru.findByTypeAndOriginalId(Agent, 12345).manager.name == 'Silas Ramsbottom'
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">agents.json</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="json">[
  {
    "id": 12345,
    "name": "Felonius Gru",
    "bio": "Born from the family with long line of villainy and formerly the world's greatest villain.",
    "securityLevel": 2,
    "manager": {
      "id": 101,
      "name": "Silas Ramsbottom"
    }
  }
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can declare the type mapping at top level so it applies to every occurrence of given type wherever in the tree:</p>
</div>
<div class="listingblock">
<div class="title">Top Level Mapping</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru reuse = Dru.create {
    from ('agents.json') {
        map {
            to (Agent) {
                map ('manager') {
                    to (Agent)
                }
            }
        }
    }

    any (Agent) {
        defaults { securityLevel = 1 }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_partial_retrieval"><a class="anchor" href="#_partial_retrieval"></a>4.7. Partial Retrieval</h3>
<div class="paragraph">
<p>You can assign just a particular property of the loaded entity, usually an <code>id</code>.</p>
</div>
<div class="listingblock">
<div class="title">Partial Retrieval</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('missionLogEntry.json') {
        map {
            to (MissionLogEntry) {
                map ('agent') {
                    to (agentId: Agent) {
                        just { id }
                        defaults {
                            securityLevel = 1
                        }
                    }
                }
            }
        }
    }
}

void 'mission log entry has agent id assigned'() {
    expect:
        dru.findByType(Agent)
        dru.findByType(MissionLogEntry).agentId == 1
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">missionLogEntry.json</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="json">{
  "mission": 7,
  "date": "2013-07-05T01:23:22Z",
  "type": "started",
  "description": "Mission started by Silas Ramsbottom",
  "agent": {
    "id": 101,
    "name": "Silas Ramsbottom"
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_data_sets"><a class="anchor" href="#_data_sets"></a>5. Data Sets</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Data set is unit of reuse in Dru. Data set can contain multiple sources and mappings.
The sources are evaluated relatively to the class in which the data set is defined. You usually defined
one data set for mapping an entity and other to load the source to maximise reuse.</p>
</div>
<div class="listingblock">
<div class="title">Agents Data Set</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>package avl

import com.agorapulse.dru.Dru
import com.agorapulse.dru.PreparedDataSet

/**
 * Agents data set.
 */
class AgentsDataSet {
    public static final PreparedDataSet agentsMapping = Dru.prepare {                   <i class="conum" data-value="1"></i><b>(1)</b>
        any (Agent) {
            map ('manager') {
                to (Agent)
            }
            defaults {
                securityLevel = 1
            }
        }
    }

    public static final PreparedDataSet agents = Dru.prepare {                          <i class="conum" data-value="2"></i><b>(2)</b>
        include agentsMapping                                                           <i class="conum" data-value="3"></i><b>(3)</b>
        from ('agents.json') {
            map {
                to (Agent)
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Define data set for agents mapping</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Define data set for agents data</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Include data set for agents mapping</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can use method <code>include</code> to include any existing data set or you can use method <code>load</code>
to load data set into existing data set.</p>
</div>
<div class="listingblock">
<div class="title">Using Data Set</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    include AgentsDataSet.agents
}

void 'agents get loaded from data set using prepare and include'() {
    expect:
        dru.findAllByType(Agent).size() == 2
        dru.findByTypeAndOriginalId(Agent, 12345).manager.name == 'Silas Ramsbottom'
}

void 'agents get loaded from data set using load'() {
    given:
        DataSet dataSet = Dru.create(this).load(AgentsDataSet.agents)
    expect:
        dataSet.findAllByType(Agent).size() == 2
        dataSet.findByTypeAndOriginalId(Agent, 12345).manager.name == 'Silas Ramsbottom'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If additional logic needs to be executed when the data set is loaded or changed significantly then you can use <code>whenLoaded</code> hook.
You can trigger the hooks manually using <code>loaded</code> method of the data set.</p>
</div>
<div class="listingblock">
<div class="title">Using Data Set Hooks</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('AGENTS') {
        map {
            to (Agent) {
                map ('manager') {
                    to (Agent) {
                        defaults { securityLevel = 1 }
                    }
                }
            }
        }
    }
}

void 'calling when loaded hook'() {
    when:
        int count = 0
        dru.load {
            whenLoaded {
                count++
            }
        }
    then:
        count == 1                                                                  <i class="conum" data-value="1"></i><b>(1)</b>
    when:
        dru.loaded()
    then:
        count == 2                                                                  <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First call to the hook is triggered immediately as we are defining the hook inside <code>load</code> method</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Second call to the hook is triggered manually using <code>loaded</code> method
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>Dru</code> is also a data set with special behaviour. It gets cleared after every test method run.
</td>
</tr>
</table>
</div></td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_parsers"><a class="anchor" href="#_parsers"></a>6. Parsers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dru loads all parsers available on the classpath automatically. Which client is used is determined by the name of the source.</p>
</div>
<div class="sect2">
<h3 id="_reflection"><a class="anchor" href="#_reflection"></a>6.1. Reflection</h3>
<div class="paragraph">
<p>Reflection parser is the simples parser. It searches for property of given name in the class where the data set is defined.
This is a default parser if any other does not support given name.</p>
</div>
<div class="listingblock">
<div class="title">Using Reflection Parser</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>private static final List&lt;Map&lt;String, Object&gt;&gt; AGENTS = [
    [
        id           : 12345,
        name         : 'Felonius Gru',
        bio          : 'Born from the family with long line of villainy and formerly the world\'s greatest villain.',
        securityLevel: 2,
        manager      : [
            id  : 101,
            name: 'Silas Ramsbottom'
        ]
    ]
]

@AutoCleanup Dru dru = Dru.create {
    from ('AGENTS') {
        map {
            to (Agent) {
                map ('manager') {
                    to (Agent) {
                        defaults { securityLevel = 1 }
                    }
                }
            }
        }
    }
}

void 'nested properties are mapped'() {
    expect:
        dru.findAllByType(Agent).size() == 2
        dru.findByTypeAndOriginalId(Agent, 12345).manager.name == 'Silas Ramsbottom'
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_json"><a class="anchor" href="#_json"></a>6.2. JSON</h3>
<div class="paragraph">
<p>JSON parser parses JSON files to combination of maps and lists. The source files must end with <code>.json</code> to get parsed and
they must be contained in directory with the same name as the reference class (unit test or data set)</p>
</div>
<div class="listingblock">
<div class="title">Using JSON Parser</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('agents.json') {
        map {
            to (Agent) {
                map ('manager') {
                    to (Agent) {
                        defaults { securityLevel = 1 }
                    }
                }
            }
        }
    }
}

void 'nested properties are mapped'() {
    expect:
        dru.findAllByType(Agent).size() == 2
        dru.findByTypeAndOriginalId(Agent, 12345).manager.name == 'Silas Ramsbottom'
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">agents.json</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="json">[
  {
    "id": 12345,
    "name": "Felonius Gru",
    "bio": "Born from the family with long line of villainy and formerly the world's greatest villain.",
    "securityLevel": 2,
    "manager": {
      "id": 101,
      "name": "Silas Ramsbottom"
    }
  }
]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_yaml"><a class="anchor" href="#_yaml"></a>6.3. YAML</h3>
<div class="paragraph">
<p>YAML parser parses YAML files to combination of maps and lists. The source files must end with <code>.yml</code> or <code>.yaml</code> to get parsed and
they must be contained in directory with the same name as the reference class (unit test or data set)</p>
</div>
<div class="listingblock">
<div class="title">Using YAML Parser</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('agents.yml') {
        map {
            to (Agent) {
                map ('manager') {
                    to (Agent) {
                        defaults { securityLevel = 1 }
                    }
                }
            }
        }
    }
}

void 'nested properties are mapped'() {
    expect:
        dru.findAllByType(Agent).size() == 2
        dru.findByTypeAndOriginalId(Agent, 12345).manager.name == 'Silas Ramsbottom'
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">agents.yml</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="yml">- id: 12345
  name: Felonius Gru
  bio: Born from the family with long line of villainy and formerly the world's greatest
    villain.
  securityLevel: 2
  manager:
    id: 101
    name: Silas Ramsbottom</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_clients"><a class="anchor" href="#_clients"></a>7. Clients</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dru loads all clients available on the classpath automatically if they support the unit test where <code>Dru</code> instance is defined.</p>
</div>
<div class="sect2">
<h3 id="_pojo"><a class="anchor" href="#_pojo"></a>7.1. POJO</h3>
<div class="paragraph">
<p>POJO client is default fallback client which loads data into Plain Old Java Objects.
POJO client is able to recognize associations but it is unable to load other sides of bidirectional relations.</p>
</div>
<div class="listingblock">
<div class="title">Using POJO Client</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('library.json') {
        map {
            to (Library)
        }
    }
}

void 'library is loaded'() {
    expect:
        dru.findAllByType(Library).size() == 1
        dru.findAllByType(Book).size() == 2
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">library.json</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="json">{
  "name": "National Library",
  "books": [
    {
      "title": "It",
      "author": "Stephen King"
    },
    {
      "title": "Leviathan Wakes",
      "author": "James S. A. Corey"
    }
  ]
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dynamodb"><a class="anchor" href="#_dynamodb"></a>7.2. DynamoDB</h3>
<div class="paragraph">
<p>DynamoDB client is extension to POJO client which understands
<a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.Annotations.html">DynamoDB data mapping annotations</a> (see bellow).
The client is used if <code>@DynamoDBTable</code> annotation is present on the class.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. DynamoDB Annotations</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Annotation</th>
<th class="tableblock halign-left valign-top">Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@DynamoDBTable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DynamoDB client is used for given class</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@DynamoDBHashKey</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property is used as hash key part of the id</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@DynamoDBRangeKey</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property is used as hash range part of the id</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@DynamoDBIgnore</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property is ignored</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@DynamoDBMarshalling</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property is marked as embedded</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>DynamoDB client determines the hash and range properly from the class so you can later retrieve the entity from the data set.</p>
</div>
<div class="listingblock">
<div class="title">Using DynamoDB Client</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('missionLogEntry.json') {
        map {
            to MissionLogEntry
        }
    }
}

void 'mission log entry has agent id assigned'() {
    given:
        String id = DynamoDB.getOriginalId(MissionLogEntry, 7, '2013-07-05T01:23:22Z')
    expect:
        dru.findByType(MissionLogEntry)
        dru.findByTypeAndOriginalId(MissionLogEntry, id)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">library.json</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="json">[
  {
    "missionId": 7,
    "date": "2013-07-05T01:23:22Z",
    "type": "started",
    "description": "Mission started by Silas Ramsbottom",
    "agentId": 101
  },
  {
    "missionId": 7,
    "date": "2013-07-06T01:23:22Z",
    "type": "succeeded",
    "description": "Mission succeeded by Silas Ramsbottom",
    "agentId": 101
  }
]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">MissionLogEntry.groovy</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@DynamoDBTable(tableName = "MissionLogEntry")
class MissionLogEntry {

    @DynamoDBHashKey
    Long missionId

    @DynamoDBRangeKey
    Date date

    MissionLogEntryType type

    String description

    @DynamoDBMarshalling(marshallerClass = ExtMarshaller)
    Map&lt;String, Object&gt; ext
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can create <code>DynamoDBMapper</code> based on the data in the data set using <code>DynamoDB.createMapper(dataSet)</code>.</p>
</div>
<div class="listingblock">
<div class="title">Using DynamoDBMapper</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>void 'use dynamodb mapper'() {
    when: "DynamoDB mapper is created from data set"
        DynamoDBMapper mapper = DynamoDB.createMapper(dru)
        Date date = new DateTime('2013-07-05T01:23:22Z').toDate()
        Long missionId = 7

    then: "loaded entities can be queried by this mapper"
        mapper.load(MissionLogEntry, missionId, date)
        mapper.load(new MissionLogEntry(missionId: missionId, date: date))
        mapper.query(MissionLogEntry,
            new DynamoDBQueryExpression&lt;MissionLogEntry&gt;().withHashKeyValues(new MissionLogEntry(missionId: missionId))
        ).size() == 2

    and: "the can be also deleted using this mapper"
        mapper.delete(mapper.load(new MissionLogEntry(missionId: missionId, date: date)))
        mapper.query(MissionLogEntry,
            new DynamoDBQueryExpression&lt;MissionLogEntry&gt;().withHashKeyValues(new MissionLogEntry(missionId: missionId))
        ).size() == 1

    when: "new entities are saved using this mapper"
        Date now = new Date()
        mapper.save(new MissionLogEntry(missionId: 7, date: now))

    then: "they are available in the data set"
        dru.findAllByType(MissionLogEntry).find { it.missionId == 7 &amp;&amp; it.date == now}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using <a href="https://github.com/agorapulse/grails-aws-sdk/tree/master/grails-aws-sdk-dynamodb">Grails AWS SDK DynamoDB Plugin</a>
you can inject such <code>DynamoDBMapper</code> into <code>AbstractDBService</code> to get instance of the service
working against the data set.</p>
</div>
<div class="listingblock">
<div class="title">Using DynamoDBMapper with Grails Plugin</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>void 'use grails service'() {
    when:
        MissionLogEntryDBService service = new MissionLogEntryDBService()
        service.mapper = DynamoDB.createMapper(dru)
    then:
        service.query(7).count == 2
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Dru&#8217;s implementation of <code>DynamoDBMapper</code> provides limited query and scan capabilities. You can
query by hash keys and range keys and you can scan with filter. For additional more complex queries you need to implement
your own logic using  <code>DruDynamoDBMapper</code> callback <code>onQuery</code> and <code>onScan</code>.</p>
</div>
<div class="listingblock">
<div class="title">Using Avanced Queries and Scans</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>void 'advanced dynamodb mapper'() {
    when: "DynamoDB mapper is created from data set"
        DruDynamoDBMapper mapper = DynamoDB.createMapper(dru)
        mapper.onQuery(MissionLogEntry) { MissionLogEntry entry, DynamoDBQueryExpression&lt;MissionLogEntry&gt; query, DynamoDBMapperConfig config -&gt;
            return entry.agentId == 101
        }
    then:
        mapper.query(MissionLogEntry, buildCompexQuery()).size() == 2

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You also so emulate failing batch using <code>onBatchWrite</code> method.</p>
</div>
<div class="listingblock">
<div class="title">Failing Batch Items</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>void 'fail some writes'() {
    when:
        DruDynamoDBMapper mapper = DynamoDB.createMapper(dru)
        mapper.onBatchWrite { Iterable&lt;MissionLogEntry&gt; toSave, Iterable&lt;MissionLogEntry&gt; toDelete -&gt;
            [new DynamoDBMapper.FailedBatch(exception: new AmazonClientException("Failed!"))]
        }
        List&lt;DynamoDBMapper.FailedBatch&gt; failed = mapper.batchSave(new MissionLogEntry(missionId: 7, date: new Date()))
    then:
        failed
        failed.size() == 1
        failed[0].exception instanceof AmazonClientException
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gorm"><a class="anchor" href="#_gorm"></a>7.3. GORM</h3>
<div class="paragraph">
<p>GORM uses the Grails Object Relational Mapping to import entities into test in-memory storage.
It automatically mocks all the entities involved so there is no need to call to <code>mockDomains</code> method.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
GORM client is unable to set the id of the entities to the original value. The original value is replaced wherever it is
obvious from the mapping to the actual generated id.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_unit_tests"><a class="anchor" href="#_unit_tests"></a>7.3.1. Unit Tests</h4>
<div class="paragraph">
<p>Your unit tests must implement <code>DataTest</code> trait if you want to take advantage of using Dru with GORM.</p>
</div>
<div class="listingblock">
<div class="title">Using GORM Client</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>@AutoCleanup Dru dru = Dru.create {
    from ('agents.json') {
        map {
            to (Agent) {
                map ('manager') {
                    to (Agent)
                }
            }
        }
    }

    any (Agent) {
        defaults { securityLevel = 1 }
    }
}

void 'entities can be accessed from data set and using GORM methods'() {
    expect:
        dru.findAllByType(Agent).size() == 2
        dru.findByTypeAndOriginalId(Agent, 12345).manager.name == 'Silas Ramsbottom'
    and:
        Agent.count() == 2
        Agent.findByName('Silas Ramsbottom').id != 12345
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">agents.json</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code data-lang="json">[
  {
    "id": 12345,
    "name": "Felonius Gru",
    "bio": "Born from the family with long line of villainy and formerly the world's greatest villain.",
    "securityLevel": 2,
    "manager": {
      "id": 101,
      "name": "Silas Ramsbottom"
    }
  }
]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Agent.groovy</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>class Agent extends Person implements WithSecurityLevel {
    String name
    String bio

    Long securityLevel

    static hasOne = [manager: Agent]

    static constraints = {
        securityLevel nullable: false
        bio nullable: true
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_integration_tests"><a class="anchor" href="#_integration_tests"></a>7.3.2. Integration Tests</h4>
<div class="paragraph">
<p>In you integration tests you no longer need to implement <code>DataTest</code> to get Dru working but <code>dru.load()</code>
needs to be run from a scope which has Hibernate session attached, e.g. inside <code>withNewSession</code> closure.</p>
</div>
<div class="listingblock">
<div class="title">Using GORM Client in Integration Test</div>
<div class="content">
<pre>@Rollback
@Integration                                                                            <i class="conum" data-value="1"></i><b>(1)</b>
class GormIntegrationSpec extends Specification {

    @AutoCleanup Dru dru = Dru.create {
        from ('agents.json') {
            map {
                to (Agent) {
                    map ('manager') {
                        to (Agent)
                    }
                }
            }
        }

        any (Agent) {
            defaults { securityLevel = 1 }
        }
    }

    void setup() {
        Agent.withNewSession { dru.load() }                                             <i class="conum" data-value="2"></i><b>(2)</b>
    }

    void 'entities can be accessed from data set and using GORM methods'() {
        expect:
            dru.findAllByType(Agent).size() == 2
            dru.findByTypeAndOriginalId(Agent, 12345).manager.name == 'Silas Ramsbottom'
        and:
            Agent.withNewSession { Agent.count() } == 2
            Agent.withNewSession { Agent.findByName('Silas Ramsbottom').id } != 12345
    }
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Test no longer implment <code>DataTest</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Dru needs to load data within Hibernate session</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_micronaut_data"><a class="anchor" href="#_micronaut_data"></a>7.4. Micronaut Data</h3>
<div class="paragraph">
<p>Dru can help you set up Micronaut Data JPA and JDBC entities if you make your test class implementing <code>io.micronaut.context.ApplicationContextProvider</code>.</p>
</div>
<div class="listingblock">
<div class="title">Using GORM Client</div>
<div class="content">
<pre class="prettyprint highlight nowrap"><code>package dru.micronaut.example.jdbc

import com.agorapulse.dru.Dru
import io.micronaut.context.ApplicationContext
import io.micronaut.context.ApplicationContextProvider
import io.micronaut.test.annotation.MicronautTest
import spock.lang.AutoCleanup
import spock.lang.Specification

import javax.inject.Inject

@MicronautTest
class BookDataSpec extends Specification implements ApplicationContextProvider {        <i class="conum" data-value="1"></i><b>(1)</b>

    private static final List&lt;Map&lt;String, Object&gt;&gt; BOOKS = [                            <i class="conum" data-value="2"></i><b>(2)</b>
        [
            id    : 12345,
            title : 'It',
            pages : 1116,
            author: [id: 666],
        ],
        [
            id    : 12666,
            title : 'The Shining',
            pages : 659,
            author: [id: 666],
        ],
    ]

    @AutoCleanup Dru dru = Dru.create {                                                 <i class="conum" data-value="3"></i><b>(3)</b>
        from 'BOOKS', {
            map {
                to Book
            }
        }
    }

    @Inject ApplicationContext applicationContext                                       <i class="conum" data-value="4"></i><b>(4)</b>
    @Inject BookRepository bookRepository                                               <i class="conum" data-value="5"></i><b>(5)</b>

    void setup() {
        dru.load()                                                                      <i class="conum" data-value="6"></i><b>(6)</b>
    }

    void 'load books'() {
        expect:
            bookRepository.count() == 2                                                 <i class="conum" data-value="7"></i><b>(7)</b>
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The specification class must implement <code>ApplicationContextProvider</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The inline data definition (could be also load from JSON or YAML using a particular parsers)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Mapping <code>BOOK</code> data to the <code>Book</code> entity</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Injecting the <code>ApplicationContext applicationContext</code> field to satisfy the <code>ApplicationContextProvider</code> interface</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Injecting the repository bean</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Loading the data before each test</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Verifying the data was loaded in the test method</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.7.0<br>
Last updated 2021-01-25 14:48:44 UTC
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js"></script>
</body>
</html>